#!/usr/bin/env perl6

use v6;
use JSON::Tiny;

sub classify(Str $rule-name) {
  $rule-name.split("_").map(*.lc.tc).join("");
}

class RuleGenerator {
  has Str $.name;
  has @.formulations;
  has Set $.tokens;

  method make-class-def {
    "class {classify($.name)} private (_source: String)";
  }

  method necessary-params(@formulation) {
    # It isn't necessary to specify a param if it can be inferred by the other params.
    #
    # e.g. here, EQUAL is not necessary:
    #
    #   layout_qualifier_id
    #     IDENTIFIER
    #     IDENTIFIER EQUAL INTCONSTANT
    #     IDENTIFIER EQUAL UINTCONSTANT
    #
    # e.g. here, PLUS and DASH are necessary:
    #
    #   additive_expression
    #     multiplicative_expression
    #     additive_expression PLUS multiplicative_expression
    #     additive_expression DASH multiplicative_expression

    my @others = @.formulations.grep(* !~~ @formulation);

    Set.new(@formulation.grep(-> $p {
      if (@formulation.elems == 1) {
        True;
      } elsif ($p (elem) $.tokens) {
        my @removed = @formulation.grep(* ne $p);
        my @with-same-length = @others.grep(*.elems == @formulation.elems);
        my @with-same-length-removed = @with-same-length.map(*.grep({$_ ne $p}));
        my @others-removed = @others.map(*.grep({$_ ne $p}));

        # Start with all the rules of the same length. If you remove this param from all
        # of them, and it was present in all of them, then it was not necessary, as long
        # as removal did not produce any duplicate rules
        !(@removed.elems == @with-same-length-removed.map(*.elems).all) &&
            @removed !~~ @others-removed.any;
      } else {
        True;
      }
    }).list);
  }

  method make-signature(@formulation) {
    my $necessary = self.necessary-params(@formulation);
    my @param-defs = @formulation.map(-> $p {
      if $p (elem) $necessary {
        "{$p}: {classify($p)}";
      } else {
        Nil;
      }
    }).grep(*.defined);

    "def this({@param-defs.join(', ')})";
  }

  method make-body(@formulation) {
    my $necessary = self.necessary-params(@formulation);
    my @formulation-strs = @formulation.map(-> $p {
      if $p (elem) $necessary {
        '${' ~ $p ~ '.source()}';
      } else {
        '${' ~ classify($p) ~ '().source()}';
      }
    });
    'this(s"' ~ @formulation-strs.join("") ~ '")';
  }

  method source-getter {
    'def source() = _source';
  }

  method source() {
    return self.make-class-def ~ "\{\n" ~
      @.formulations
        .map( -> $f { '  ' ~ self.make-signature($f) ~ ' = ' ~ self.make-body($f) } )
        .join("\n") ~
      "\n  " ~ self.source-getter ~
      "\n\}";
  }
}

class TokenGenerator {
  has Str $.name;
  has Str $.source;

  method source() {
    return q:to/SOURCE/;
      class ${classify($.name)} {
        def source() = "${$.source}"
      }
      SOURCE
  }
}

grammar GrammarFile {
  token TOP {
    ^ <node>* $
  }

  proto token node { * }

  token node:sym<comment> {
    '//' <-[\n]>+ \n
  }

  token node:sym<rule> {
    <rule-name> ':' \n
    <formulation>+
  }

  token formulation {
    \s* [ <rule-name>+ % ' '+ ] \n
  }

  token rule-name {
    \w+
  }
}

class GrammarActions {
  has Set $.tokens;

  method TOP($/) {
    $/.make($<node>.map(*.made).grep(*.defined));
  }

  method node:sym<comment>($/) {
    $/.make(Nil);
  }

  method node:sym<rule>($/) {
    $/.make(RuleGenerator.new(
        name => $<rule-name>.Str,
        formulations => ($<formulation> || []).map(*.made),
        tokens => $.tokens
      ));
  }

  method formulation($/) {
    $/.make($<rule-name>.map(*.Str).grep(* ne 'EMPTY'));
  }
}

# todo: handle IDENTIFIER, TYPE_NAME, (FLOAT|INT|UINT|BOOL)CONSTANT, FIELD_SELECTION

#| Creates codegen classes from the GLES 3.0 grammar.
sub MAIN(Str :$grammar-file, Str :$tokens-file, Str :$output-dir) {
  my $contents = $grammar-file.IO.slurp;
  my %tokens = from-json($tokens-file.IO.slurp);
  my @rules = GrammarFile.parse(
      $contents,
      actions => GrammarActions.new(
          tokens => Set.new(%tokens.keys))).made;
  say @rules.map(*.source).join("\n\n");
}
